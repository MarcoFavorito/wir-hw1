<HEAD>
<TITLE> Fondamenti di Informatica II.  Programma d'esame</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<DIV ALIGN=CENTER><P ALIGN=CENTER><BIG CLASS=XXLARGE><B>Fondamenti di Informatica II</B></BIG><BR> 
  <BIG CLASS=LARGE><B>A.A. 2000/2001 --  Prof. Marco Cadoli</B></BIG>
</P></DIV>


<EM>Corso di laurea</EM>: Ingegneria Informatica<BR>

<EM>Propedeuticit&#224;</EM>: Fondamenti di Informatica I<BR><BR><BR>



<BIG CLASS=XLARGE> <B>Programma d'esame</B>
</BIG>

<UL><LI>  <B>Ciclo di vita del software e qualit&#224; dei programmi</B><BR> 

Il contesto organizzativo. Il ciclo di sviluppo dei programmi. Raccolta e
analisi dei requisiti.  Progettazione. Verifica. Manutenzione. Le qualit&#224;
dei programmi.
<BR>
<U>Riferimenti</U>:  [1 -- Cap. 1]



<P><LI> <B>Introduzione al C++</B><BR>

Elementi di base del C++. Struttura di un programma. Espressioni e
istruzioni.  Strutture di controllo. Tipi di dato. Funzioni. Overloading di
funzioni. Operazioni elementari su file. Programmi divisi in pi&ugrave; file.
Le classi in C++. L'ereditariet&#224; in C++.
<BR>
<U>Riferimenti</U>: [1 -- Capp. 3, 4, 5], [2 -- Capp. 1 - 7]
                    [<I>Facoltativo:</I> 4 -- Capp. 1 - 12]

<P><LI> <B>La progettazione dei programmi</B><BR>

La fase di progettazione. Principi di progettazione.  Concettualizzazione e
realizzazione. Tecniche di progettazione. La modularizzazione. Criteri per la
modularizzazione. Tipi di modularizzazione: funzionale, per oggetto, per tipo
astratto. La modularizzazione in fase di concettualizzazione e in fase di
realizzazione.  Schema di una metodologia basata sulla modularizzazione.
<BR>
<U>Riferimenti</U>:   [1 -- Capp. 2, 9]


<P><LI> <B>Tipi astratti di dato: definizione e specifica</B><BR>

Modularizzazione per tipo astratto: concettualizzazione. La specifica dei
tipi astratti.  La specifica di alcuni importanti tipi astratti. 
Cenni alla formalizzazione algebrica dei tipi
astratti. Classificazione di tipi astratti: tipi come astrazione di valori,
tipi come astrazione di entit&#224;.
<BR>
 <U>Riferimenti</U>:  [1 -- Cap. 10] [1 -- Capp. 7 e 11 (sola lettura)]

<P><LI> <B>Tipi astratti di dato: realizzazione</B><BR>

Realizzazione di tipi astratti mediante classi in C++.  Qualit&#224; delle
realizzazioni di tipi astratti. Rappresentazione di tipi astratti e di
strutture di dati: array, liste, code, pile, insiemi, alberi, grafi. Schemi
realizzativi.  L'interfaccia di classe.  Schemi realizzativi funzionali, con
side-effect, con condivisione di memoria e senza condivisione di memoria.
Utilizzo di classi da parte di moduli esterni. Approfondimenti sulla
metodologia.  Realizzazione di classi come astrazione di valori e di classi
come astrazione di entit&#224;.  Caratterizzazione dell'orientazione agli
oggetti per la realizzazione di tipi astratti. Realizzazione delle relazioni
<I>has-a</I> e <I>has-many</I>. Tipi astratti e ereditariet&#224;.
Realizzazione della relazione <I>is-a</I>. Raffinamento della rappresentazione.
Classe base come supporto per la rappresentazione. Altri usi
dell'ereditariet&#224;. Esempi di realizzazione di tipi astratti mediante
classi.
<BR>
<U>Riferimenti</U>:  [1 -- Capp. 12, 13, 14], [2 -- Capp. 8 - 10, 13 - 17],
                     [<I>Facoltativo:</I> 4 -- Capp. 14, 15]

<P><LI> <B>Introduzione a Java</B><BR>

Sintassi di Java. Programmazione a oggetti in Java. Progettazione di classi
in Java.
<BR>
<U>Riferimenti</U>: [3]


<P><LI> <B>Tecniche per il progetto e l'analisi di algoritmi</B><BR>

Misure di complessit&#224; degli algoritmi. L'analisi asintotica e le relative
notazioni. Costo di esecuzione di un algoritmo. Delimitazione superiore ed
inferiore della complessit&#224; di un problema. Problemi e loro specifica.
Classificazione di problemi: problemi di decisione, di ricerca e di
ottimizzazione.  Lo spazio di ricerca. Introduzione alle tecniche
algoritmiche. La tecnica dell'enumerazione. Schemi di realizzazione in C++ di
algoritmi di enumerazione. La tecnica del backtracking. Schemi di
realizzazione in C++ di algoritmi di backtracking.  La tecnica golosa.
Applicabilit&#224; della tecnica golosa.
<!--
     La tecnica divide et impera.
Caratterizzazione della complessit&#224; di algoritmi divide et impera.
Rappresentazione di dizionari mediante tavole, rappresentazione di
dizionari mediante alberi, code di priorit&#224;, heap.
-->
     Studi di caso.
<BR>
<U>Riferimenti</U>:    [1 -- Capp. 8, 15 - 22], [2 -- Capp. 11, 12, 18 - 30]

</UL>


<BIG CLASS=XLARGE> <B>Materiale didattico adottato</B>
</BIG>

<DL COMPACT><DT><STRONG>[ 1]</STRONG>
<DD> M. Cadoli, M. Lenzerini, P. Naggar, A. Schaerf. 
     <A HREF="http://www.dis.uniroma1.it/pub/clns">
<EM>Fondamenti 
    della progettazione dei programmi: Principi, tecniche e loro
    applicazioni in C++.</EM></A> Citt&agrave;<I>Studi</I>Edizioni, UTET
    Libreria, 1997.
<DT><STRONG>[ 2]</STRONG>
<DD> M. Cadoli, E. Panizzi, A. Schaerf., M. Lenzerini.
     <A HREF="http://www.dis.uniroma1.it/pub/clps">
   <EM>Esercizi di
    progettazione dei programmi in C++.</EM></A>
    Citt&agrave;<I>Studi</I>Edizioni, UTET Libreria, 1998.
<DT><STRONG>[ 3]</STRONG>
<DD> M. Cadoli, M. Lenzerini, <EM> Dispensa del corso A.A. 2000/2001.</EM>
    In distribuzione presso L'UNIVERSITARIA, v.le Ippocrate 99, Roma.
 </DL>


<BIG CLASS=XLARGE> <B>Materiale didattico consigliato</B>
</BIG>
<DL COMPACT><DT><STRONG>[ 4]</STRONG>
<DD> D.M. Capper. <EM>Introduzione a C++ per le scienze e
            l'ingegneria.</EM> McGraw-Hill, 1997.
 
 </DL>


<HR>

<I>Ultimo aggiornamento di questo file:
<!-- hhmts start -->
Last modified: Wed May 23 14:54:15 2001
<!-- hhmts end -->
<HR>
