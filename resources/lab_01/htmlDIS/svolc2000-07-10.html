<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML lang="en"><HEAD>
<META http-equiv="Generator" content="com.bluecraft.htmlize">
<TITLE>Source Code: svolc2000-07-10.c</TITLE>
<STYLE>
body {
    background: ivory;
    color: black;
}
DIV.description {
    color: maroon;
    margin-top: -0.4cm;
}
SPAN.linenumber {
    color: maroon;
}
SPAN.string {
    color: red;
}
SPAN.comment {
    color: green;
}
SPAN.keyword {
    color: blue;
}
SPAN.userkeyword {
    color: purple;
    font-weight: bold;
}
</STYLE>
</HEAD><BODY>
<H2>svolc2000-07-10.c</H2>
<DIV class="description">
Generated by <STRONG>com.bluecraft.htmlize</STRONG> HTML-ization Utility Classes.
</DIV>
<PRE>
<SPAN class="comment">/* 
 * Svolgimento problema di esame del 10/7/2000
 *      (Il file sulle opere d'arte va costruito separatamente, tramite un editor) 
 *
 *      
 *
 * Il programma che segue è stato sviluppato dando particolare enfasi 
 * ai criteri per la progettazione di "buon software", quali ad esempio
 * costruzione top-down, decomposizione funzionale, uso di 
 * tipi di dato efficaci e descrittivi. 
 *
 * La soluzione proposta fa uso di array dinamici. Nella soluzione il
 * docente ha inserito vari aspetti avanzati del C (pur rimanendo nell'ambito
 * degli argomenti in programma). Si tratta dunque di un (raro) esempio di 
 *
 *                        SOLUZIONE AVANZATA
 *
 */</SPAN>


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define LUNAUT 16
#define LUNOP 11
#define LUNNOMEFILE 30

typedef unsigned short <SPAN class="userkeyword">int</SPAN> ushort;

typedef struct {
    <SPAN class="userkeyword">char</SPAN> autore[LUNAUT],
         opera[LUNOP],
         tipoopera;
    float europrezzo;
} schedaopera;

typedef struct {
    ushort dimarray;
    schedaopera *punarray;
} arraydinamicodiopere;

<SPAN class="comment">/* prototipi */</SPAN>
    FILE *ApriFile(<SPAN class="userkeyword">char</SPAN> *, <SPAN class="userkeyword">char</SPAN> *);
    <SPAN class="userkeyword">void</SPAN> *Alloca(size_t);
    <SPAN class="userkeyword">void</SPAN> *Realloca(<SPAN class="userkeyword">void</SPAN> *, size_t);
    <SPAN class="userkeyword">void</SPAN> MaxTest(float , float *, ushort *);
    <SPAN class="userkeyword">void</SPAN> TrovaMaxPrezzi(FILE *, float *, float *, ushort *, ushort *);
    <SPAN class="userkeyword">void</SPAN> RaccogliOpereCare(schedaopera, float, schedaopera *, ushort *);
    <SPAN class="userkeyword">void</SPAN> OpereCare(<SPAN class="userkeyword">char</SPAN> *, arraydinamicodiopere *, arraydinamicodiopere *);
    <SPAN class="userkeyword">void</SPAN> StampaArrayOpere(arraydinamicodiopere);
    float ValoreMassimo(<SPAN class="userkeyword">char</SPAN> *);
    <SPAN class="userkeyword">int</SPAN> <SPAN class="userkeyword">main</SPAN>(<SPAN class="userkeyword">void</SPAN>);


FILE *ApriFile(<SPAN class="userkeyword">char</SPAN> *nome, <SPAN class="userkeyword">char</SPAN> *modo)
{
    FILE *f;
    
    f=fopen(nome, modo);
    if(f==NULL) {
        fprintf(stderr, <SPAN class="string">"Impossibile aprire \"%s\" in modalità \"%s\". Programma terminato.\n"</SPAN>, nome, modo);
        exit(1);
    }
    return f;
}


<SPAN class="userkeyword">void</SPAN> *Alloca(size_t numbyte)
{
    <SPAN class="userkeyword">void</SPAN> *p;
    
    p=malloc(numbyte);
    if(p==NULL) {
        fprintf(stderr, <SPAN class="string">"Impossibile allocare %lu byte. Programma terminato.\n"</SPAN>, numbyte);
        exit(2);
    }
    return p;
}


<SPAN class="userkeyword">void</SPAN> *Realloca(<SPAN class="userkeyword">void</SPAN> *punblocco, size_t numbyte)
<SPAN class="comment">/* 
 * Viene fatto uso della funzione di libreria ANSI realloc(void *punblocco, size_t numbyte).
 * La funzione modifica la dimensione del blocco di memoria puntato da punblocco in modo
 * da ottenere un blocco di numbyte byte, valore che può essere inferiore o superiore alla
 * dimensione corrente del blocco. Il parametro punblocco deve puntare ad un blocco precedentemente
 * allocato con malloc(), realloc() o altre funzioni similari. Se numbyte è zero il blocco
 * puntato da punblocco viene deallocato. Se punblocco è NULL realloc() alloca numbyte byte.
 * Il contenuto del blocco di memoria viene preservato se il nuovo blocco è più grande del
 * precedente. Se il nuovo blocco è più piccolo i byte finali extra vengono tagliati via.
 * realloc() restituisce un puntatore al nuovo blocco se l'allocazione ha successo e se numbyte
 * è maggiore di zero; in caso di insuccesso o numbyte nullo restituisce NULL
 */</SPAN>
{
    <SPAN class="userkeyword">void</SPAN> *p;
    
    p=realloc(punblocco,numbyte);
    if(p==NULL) {
        fprintf(stderr, <SPAN class="string">"Impossibile reallocare %lu byte. Programma terminato.\n"</SPAN>, numbyte);
        exit(2);
    }
    return p;
}


<SPAN class="userkeyword">void</SPAN> MaxTest(float prezzo, float *maxprezzo, ushort *contamaxprezzo)
{
    if(prezzo &gt; *maxprezzo) {
        *maxprezzo = prezzo;
        *contamaxprezzo = 1;
    } else if (prezzo == *maxprezzo)
        (*contamaxprezzo)++;
    return;
}


<SPAN class="userkeyword">void</SPAN> TrovaMaxPrezzi(FILE *f, float *maxprezzoquadri, float *maxprezzosculture, ushort *contaquadrimaxprezzo, ushort *contasculturemaxprezzo)
{
    schedaopera opera;
    
    *maxprezzoquadri = *maxprezzosculture = 0;
    *contaquadrimaxprezzo = *contasculturemaxprezzo = 0;
    fscanf(f, <SPAN class="string">"%s %s %c %g "</SPAN>, opera.autore, opera.opera, &amp;opera.tipoopera, &amp;opera.europrezzo);
    while(!feof(f)) {
        switch(opera.tipoopera) {
            case <SPAN class="string">'Q'</SPAN>: MaxTest(opera.europrezzo, maxprezzoquadri, contaquadrimaxprezzo);
                      break;
            case <SPAN class="string">'S'</SPAN>: MaxTest(opera.europrezzo, maxprezzosculture, contasculturemaxprezzo);
                      break;
            default : printf(<SPAN class="string">"Tipo di opera non riconosciuto.\n"</SPAN>); 
                      break;
        }
        fscanf(f, <SPAN class="string">"%s %s %c %g "</SPAN>, opera.autore, opera.opera, &amp;opera.tipoopera, &amp;opera.europrezzo);
    }
   return;
}


<SPAN class="userkeyword">void</SPAN> RaccogliOpereCare(schedaopera opera, float maxprezzo, schedaopera *cellaarray, ushort *i)
{
    if(opera.europrezzo == maxprezzo) {
        *cellaarray = opera; 
        (*i)++;
    }
    return;
}



<SPAN class="userkeyword">void</SPAN> OpereCare(<SPAN class="userkeyword">char</SPAN> *nomefile, arraydinamicodiopere *quadricari, arraydinamicodiopere *sculturecare)
<SPAN class="comment">/* Funzione richiesta al p.to 2 */</SPAN>
{
    float maxprezzoquadri, maxprezzosculture;
    FILE *f;
    schedaopera opera;
    ushort contaquadrimaxprezzo, contasculturemaxprezzo, q, s;
    
    f=ApriFile(nomefile, <SPAN class="string">"r"</SPAN>);
    TrovaMaxPrezzi(f, &amp;maxprezzoquadri, &amp;maxprezzosculture, &amp;contaquadrimaxprezzo, &amp;contasculturemaxprezzo);
    
    quadricari-&gt;dimarray=contaquadrimaxprezzo;
    quadricari-&gt;punarray=Alloca(contaquadrimaxprezzo*sizeof(schedaopera));
   
    sculturecare-&gt;dimarray=contasculturemaxprezzo;
    sculturecare-&gt;punarray=Alloca(contasculturemaxprezzo*sizeof(schedaopera));
    
    q = s = 0;
    rewind(f);
    fscanf(f, <SPAN class="string">"%s %s %c %g "</SPAN>, opera.autore, opera.opera, &amp;opera.tipoopera, &amp;opera.europrezzo);
    while(!feof(f)) {
        switch(opera.tipoopera) {
            case <SPAN class="string">'Q'</SPAN>: RaccogliOpereCare(opera, maxprezzoquadri, &amp;((quadricari-&gt;punarray)[q]), &amp;q);
                      break;
            case <SPAN class="string">'S'</SPAN>: RaccogliOpereCare(opera, maxprezzosculture, &amp;((sculturecare-&gt;punarray)[s]), &amp;s);
                      break;
            default : printf(<SPAN class="string">"Tipo di opera non riconosciuto.\n"</SPAN>); 
                      break;
        }
        fscanf(f, <SPAN class="string">"%s %s %c %g "</SPAN>, opera.autore, opera.opera, &amp;opera.tipoopera, &amp;opera.europrezzo);
    }
    fclose(f);
    return;
}

<SPAN class="userkeyword">void</SPAN> StampaArrayOpere(arraydinamicodiopere arr)
{
    ushort i;
    schedaopera *p=arr.punarray;
    
    switch (p[0].tipoopera) {
        case <SPAN class="string">'Q'</SPAN>:
            printf(<SPAN class="string">"Stampa di un array di %hu quadri:\n"</SPAN>, arr.dimarray);
            break;
        case <SPAN class="string">'S'</SPAN>:
            printf(<SPAN class="string">"Stampa di un array di %hu sculture:\n"</SPAN>, arr.dimarray);
            break;
        default:
            printf(<SPAN class="string">"Tipo di opera non riconosciuto, la stampa non può aver luogo.\n"</SPAN>); 
            return;
    }
    
    printf(<SPAN class="string">"----------------------------------------------\n"</SPAN>);
    printf(<SPAN class="string">"|    Autore     |  Titolo  | Tipo |  Prezzo  |\n"</SPAN>);
    printf(<SPAN class="string">"|---------------|----------|------|----------|\n"</SPAN>);
    for(i=0; i&lt;arr.dimarray; i++)
        printf(<SPAN class="string">"|%-*s|%-*s|   %c  |%10g|\n"</SPAN>, LUNAUT-1, p[i].autore, LUNOP-1, p[i].opera, p[i].tipoopera, p[i].europrezzo);
    printf(<SPAN class="string">"----------------------------------------------\n"</SPAN>);
    
    return;
}


<SPAN class="comment">/* Visibilità: da qui in poi */</SPAN>

typedef struct {
    <SPAN class="userkeyword">char</SPAN> autore[LUNAUT];
    float valoreautore;
} schedaautore;

typedef struct {
    ushort dimarray;
    schedaautore *punarray;
} arraydinamicodiautori;

<SPAN class="comment">/* ulteriore prototipo (che fa uso dei tipi testè definiti) */</SPAN>
    <SPAN class="userkeyword">int</SPAN> AutorePresente(arraydinamicodiautori, <SPAN class="userkeyword">char</SPAN> *, ushort *);

<SPAN class="userkeyword">int</SPAN> AutorePresente(arraydinamicodiautori a, <SPAN class="userkeyword">char</SPAN> *autore, ushort *i)
<SPAN class="comment">/*
 * Restituisce 1 se nell'array dinamico a è già presente una scheda
 * relativa all'autore autore; in tal caso restituisce tramite il
 * parametro di output i la posizione della cella crelativa ad autore.
 * In caso di assenza restituisce 0 (ed il valore di i non è rilevante)
 */</SPAN>
{
    for(*i=0; *i&lt;a.dimarray; (*i)++)
        if(strcmp((a.punarray)[*i].autore, autore) == 0)
            return 1;
    return 0;
}



float ValoreMassimo(<SPAN class="userkeyword">char</SPAN> *nomefile)
<SPAN class="comment">/* Funzione richiesta al p.to 3 */</SPAN>
{
    arraydinamicodiautori arr;
    ushort dove, i;
    float valmax;
    FILE *f;
    schedaopera opera;
    
    arr.dimarray = 0;
    arr.punarray = NULL;
    f=ApriFile(nomefile, <SPAN class="string">"r"</SPAN>);
    fscanf(f, <SPAN class="string">"%s %s %c %g "</SPAN>, opera.autore, opera.opera, &amp;opera.tipoopera, &amp;opera.europrezzo);
    while(!feof(f)) {
        if(AutorePresente(arr, opera.autore, &amp;dove))
            (arr.punarray)[dove].valoreautore += opera.europrezzo;
        else {
            arr.punarray = Realloca(arr.punarray,(arr.dimarray+1)*sizeof(schedaautore));
            strcpy((arr.punarray)[arr.dimarray].autore, opera.autore);
            (arr.punarray)[arr.dimarray].valoreautore = opera.europrezzo;
            arr.dimarray++;
        }
        fscanf(f, <SPAN class="string">"%s %s %c %g "</SPAN>, opera.autore, opera.opera, &amp;opera.tipoopera, &amp;opera.europrezzo);
    }
    fclose(f);
    
    <SPAN class="comment">/* Cerca ora il valore massimo */</SPAN>
    valmax = 0;
    for(i=0; i&lt;arr.dimarray; i++)
        if((arr.punarray)[i].valoreautore &gt; valmax)
            valmax = (arr.punarray)[i].valoreautore;
            
    free(arr.punarray);
    
    return valmax;
}
      


<SPAN class="userkeyword">int</SPAN> <SPAN class="userkeyword">main</SPAN>(<SPAN class="userkeyword">void</SPAN>)
{
    <SPAN class="comment">/* per array dinamici */</SPAN>
    arraydinamicodiopere quadricari, sculturecare; 
    
    <SPAN class="userkeyword">char</SPAN> nomefile[LUNNOMEFILE];
    
    printf(<SPAN class="string">"Nome file?\n\t"</SPAN>);
    gets(nomefile);
    
    <SPAN class="comment">/* chiamata funzione richiesta al p.to 2 */</SPAN>
    OpereCare(nomefile, &amp;quadricari, &amp;sculturecare);
    
    <SPAN class="comment">/* stampe di verifica */</SPAN>
    StampaArrayOpere(quadricari);          
    StampaArrayOpere(sculturecare);
    
    free(quadricari.punarray);
    free(sculturecare.punarray);
    
    <SPAN class="comment">/* chiamata funzione richiesta al p.to 3, con stampa di verifica */</SPAN>
    printf(<SPAN class="string">"Il valore massimo complessivo associato ad un autore è %g.\n"</SPAN>, ValoreMassimo(nomefile));
    
    return 0;
}

</PRE>
</BODY></HTML>
