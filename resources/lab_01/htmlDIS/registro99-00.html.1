<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.6 [en] (X11; I; SunOS 5.5.1 sun4u) [Netscape]">
   <title>Registro lezioni AA 1999/2000 del Corso di
Fondamenti di Informatica II - secondo modulo,
Universit&agrave; di Roma "La Sapienza"&lt;/H2>
</title>
</head>
<body>

<center> <h2> Diploma Universitario in Ingegneria Informatica</h2></center>

<center> <h1> Fondamenti di Informatica II - secondo modulo</h1></center>

<center> <h2> Lezioni faccia a faccia A.A. 1999/2000</h2></center>

<center> <h3> docente: <a href="http://www.dis.uniroma1.it/~degiacomo">Giuseppe
De Giacomo</a></h3></center>

<hr><b>Materiale didattico: testi adottati</b>
<p>

<b>[T1]</b> M. Cadoli, M. Lenzerini, P. Naggar, A. Schaerf, <i><a href="http://www.dis.uniroma1.it/pub/clns">Fondamenti
della progettazione dei programmi: principi, tecniche e loro applicazione
in C++</a></i>, Citt&aacute;<i>Studi</i>Edizioni, UTET Libreria, 1997.
<br>

<b>[T2]</b> M. Cadoli, E. Panizzi, A. Schaerf., M. Lenzerini. <i><a
href="http://www.dis.uniroma1.it/pub/clps">Esercizi di progettazione dei
programmi in C++.</a></i> Citt&aacute;<i>Studi</i>Edizioni, UTET Libreria,
1998.  <br>

<b>[T3]</b>  T.H. Cormen, C.E. Leiserson, R.L. Rivest,
<i>Introduzione agli Algoritmi, </i>Jackson Libri, 1999.
<p>

<!--

SPECIFICA:

10 ore ereditarieta' C++
6  ore complessita'
20 ore strutture dati avanzate
14 ore tecniche algoritmiche
------------------------------------------
50 ore totale

-->
<hr>

<tt>File contenete tutta la directory di Fondamenti II secondo modulo (inclusi
tutti i programmi fatti a lezione): <a href="fond2mod2.tar">fond2mod2.tar</a></tt>

<hr>
<center>
<h2>
Lezioni faccia a faccia - tabella riassuntiva</h2></center>

<center><table BORDER WIDTH="90%" >
<caption><!--
  <TR>
  <TD VALIGN=CENTER WIDTH="20%"><I><FONT COLOR="#008000"></FONT></I></TD>
  <TD VALIGN=TOP WIDTH="23%">&nbsp;</TD>
  <TD VALIGN=CENTER WIDTH="23%">&nbsp;</TD>
  <TD VALIGN=CENTER WIDTH="23%"><B><FONT COLOR="#FF0000">ESAME</FONT></B>
  <P><FONT COLOR="#0000FF">XX dicembre</FONT></TD>
  <TD VALIGN=CENTER WIDTH="23%">&nbsp;</TD>
  </TR>
--></caption>

<tr>
<td VALIGN=CENTER WIDTH="20%"><i><font color="#008000">Settimana</font></i></td>

<td VALIGN=TOP WIDTH="10%"><i><font color="#008000">Argomento</font></i></td>

<td VALIGN=CENTER WIDTH="25%"><i><font color="#008000">Martedi (ore 14-17)</font></i></td>

<td VALIGN=CENTER WIDTH="25%"><i><font color="#008000">Giovedi (ore 11-13)</font></i></td>

<td VALIGN=CENTER WIDTH="25%"><i><font color="#008000">Venerdi (ore 11-13)</font></i></td>
</tr

<tr> <td VALIGN=CENTER WIDTH="15%"><i><font color="#008000">
<b>1:</b>11-15gen</font></i></td>

<td VALIGN=TOP WIDTH="23%"><font
color="#0000FF">Ereditariet&agrave;</font></td>

<td VALIGN=CENTER WIDTH="23%">Ereditariet&agrave; in C++<br> <font
color="#FF0000">(<a href="#Mar1">Lez 1,2,3</a>)</font></td>

<td VALIGN=CENTER WIDTH="23%">Ereditariet&agrave; in C++<br>
<font color="#FF0000">(<a href="#Gio1">Lez 4,5</a>)</font></td>

<td VALIGN=CENTER WIDTH="23%">Ereditariet&agrave; in C++, Pile, Code<br>
<font color="#FF0000">(<a href="#Ven1">Lez 6,7</a>)</font></td>


<tr> <td VALIGN=CENTER WIDTH="15%"><i><font
color="#008000"><b>2:</b>17-22gen</font></i></td>

<td VALIGN=TOP WIDTH="23%"><font color="#0000FF">Ereditarie&agrave;</font></td>

<td VALIGN=CENTER WIDTH="23%"><center>----</center></font></td>

<td VALIGN=CENTER WIDTH="23%">Tipi astratti ed ereditariet&agrave;<br>
<font color="#FF0000">(<a href="#Gio2">Lez 8,9</a>)</font></td>

<td VALIGN=CENTER WIDTH="23%">Tipi astratti ed ereditariet&agrave;<br>
<font color="#FF0000">(<a href="#Ven2">Lez 10,11</a>)</font></td> </tr>

<tr>
<td VALIGN=CENTER WIDTH="20%"><i><font color="#008000"><b>3:</b>24-29gen</font></i></td>

<td VALIGN=TOP WIDTH="23%"><font color="#0000FF">Complessit&agrave;</font></td>

<td VALIGN=CENTER WIDTH="23%">Complessit&agrave;<br>
<font color="#FF0000">(<a href="#Mar3">Lez 12,13,14</a>)</font></td>

<td VALIGN=CENTER WIDTH="23%">Complessit&agrave; asintotica<br><font color="#FF0000">(<a href="#Gio3">Lez 15,16</a>)</font></td>

<td VALIGN=CENTER WIDTH="23%">Complessit&agrave; di problemi<br><font color="#FF0000">(<a href="#Ven3">Lez 17,18</a>)</font></td> </tr>

<tr>
<td VALIGN=CENTER WIDTH="20%"><i><font color="#008000"><b>4:</b>28-5feb</font></i></td>

<td VALIGN=TOP WIDTH="23%"><font color="#0000FF">Strutture dati</font></td>

<td VALIGN=CENTER WIDTH="23%">Heap e Code di Priorit&agrave;<br>
<font color="#FF0000">(<a href="#Mar4">Lez 19,20,21</a>)</font>
</td>
<td VALIGN=CENTER WIDTH="23%">Alberi n-ari<br>
<font color="#FF0000">(<a href="#Gio4">Lez 22,23</a>)</font></td>
<td VALIGN=CENTER WIDTH="23%">HeapSort<br>
<font color="#FF0000">(<a href="#Ven4">Lez 24,25</a>)</font></td>


<tr>
<td VALIGN=CENTER WIDTH="20%"><i><font color="#008000"><b>5:</b>7-12feb</font></i></td>

<td VALIGN=TOP WIDTH="23%"><font color="#0000FF">Strutture dati</font></td>

<td VALIGN=CENTER WIDTH="23%">Dizionari, Alberi di Ricerca<br>
<font color="#FF0000">(<a href="#Mar5">Lez 26,27,28</a>)</font>
</td>
<td VALIGN=CENTER WIDTH="23%">Realizz. Alberi di Ricerca<br>
<font color="#FF0000">(<a href="#Gio5">Lez 29,30</a>)</font>
</td>
<td VALIGN=CENTER WIDTH="23%">Realizz. Dizionari<br>
<font color="#FF0000">(<a href="#Ven5">Lez 31,32</a>)</font></td>
</tr>

<tr>

<td VALIGN=CENTER WIDTH="20%"><i><font color="#008000"><b>6:</b>14-19feb</font></i></td>

<td VALIGN=TOP WIDTH="23%"><font color="#0000FF">Strutture dati</font></td>

<td VALIGN=CENTER WIDTH="23%">Alberi AVL<br>
<font color="#FF0000">(<a href="#Mar6">Lez 33,34,35</a>)</font>
</td>
<td VALIGN=CENTER WIDTH="23%">Realizz. Alberi AVL<br>
<font color="#FF0000">(<a href="#Gio6">Lez 36,37</a>)</font>
</td>
<td VALIGN=CENTER WIDTH="23%">Esercizio d'esame su uso strutture dati<br>
<font color="#FF0000">(<a href="#Ven6">Lez 38,39</a>)</font></td>
</tr>

<tr>
<td VALIGN=CENTER WIDTH="20%"><i><font color="#008000"><b>7:</b>21-26feb</font></i></td>

<td VALIGN=TOP WIDTH="23%"><font color="#0000FF">Strutture dati</font></td>

<td VALIGN=CENTER WIDTH="23%">Hashing<br>
<font color="#FF0000">(<a href="#Mar7">Lez 40,41,42</a>)</font>
</td>
<td VALIGN=CENTER WIDTH="23%">Hashing<br>
<font color="#FF0000">(<a href="#Gio7">Lez 43,44</a>)</font>
</td>
<td VALIGN=CENTER WIDTH="23%">Divide at Impera<br>
<font color="#FF0000">(<a href="#Ven7">Lez 45,46</a>)</font></td>
</tr>

<tr>
<td VALIGN=CENTER WIDTH="20%"><i><font color="#008000"><b>8:</b>28-4mar</font></i></td>

<td VALIGN=TOP WIDTH="23%"><font color="#0000FF">Tecniche algoritmiche</font></td>

<td VALIGN=CENTER WIDTH="23%">Algoritmi golosi<br>
<font color="#FF0000">(<a href="#Mar8">Lez 47,48,49</a>)</font>
</td>
<td VALIGN=CENTER WIDTH="23%">Algoritmi golosi<br>
<font color="#FF0000">(<a href="#Gio8">Lez 50,51</a>)</font>
</td>
<td VALIGN=CENTER WIDTH="23%"><center>----</center></td>

</tr>

<tr>
<td VALIGN=CENTER WIDTH="20%"><i><font color="#008000"><b>9:</b>6-11mar</font></i></td>

<td VALIGN=TOP WIDTH="23%"><font color="#0000FF">Tecniche algoritmiche</font></td>

<td VALIGN=CENTER WIDTH="23%"><center><i>interruzione attivita didattica</i></center></td>

<td VALIGN=CENTER WIDTH="23%">Algoritmi su grafi<br>
<font color="#FF0000">(<a href="#Gio9">Lez 52,53</a>)</font>
</td>
<td VALIGN=CENTER WIDTH="23%">Algoritmi su grafi<br>
<font color="#FF0000">(<a href="#Ven9">Lez 54,55</a>)</font></td>

</tr>

<tr>
<td VALIGN=CENTER WIDTH="20%"><i><font color="#008000"><b>10:</b>13-18mar</font></i></td>

<td VALIGN=TOP WIDTH="23%"><font color="#0000FF">Tecniche algoritmiche</font></td>

<td VALIGN=CENTER WIDTH="23%">Algoritmi su grafi<br>
<font color="#FF0000">(<a href="#Mar10">Lez 56,57,58</a>)</font>
</td>
<td VALIGN=CENTER WIDTH="23%">Algoritmi su grafi<br>
<font color="#FF0000">(<a href="#Gio10">Lez 59,60</a>)</font>
</td>
<td VALIGN=CENTER WIDTH="23%">Algoritmi su grafi<br>
<font color="#FF0000">(<a href="#Ven10">Lez 61,62</a>)</font></td>

<tr>
<td VALIGN=CENTER WIDTH="20%"><i><font color="#008000"><b>11:</b>20-25mar</font></i></td>

<td VALIGN=TOP WIDTH="23%"><font color="#0000FF">Ripasso</font></td>

<td VALIGN=CENTER WIDTH="23%">Esercizi d'esame<br>
<font color="#FF0000">(<a href="#Es11">Es</a>)</font>
</td>
<td VALIGN=CENTER WIDTH="23%">Esercizi d'esame<br>
<font color="#FF0000">(<a href="#Es11">Es</a>)</font>
</td>
<td VALIGN=CENTER WIDTH="23%">Esercizi d'esame<br>
<font color="#FF0000">(<a href="#Es11">Es</a>)</font>
</td>

</tr>

</table></center>

<p>
<hr>
<center>
<h2>
Lezioni faccia a faccia - dettaglio</h2></center>

<hr><a NAME="Mar1"></a>
<ul>
<li>
<b>Lezione 1,2,3 - 11/1/00</b></li>


<ul>

<li><b>Argomenti trattati</b>[T1, Cap. 5, parr. 5.1-5.4]</li>

<ul>
  <li>Presentazione del corso</li>
  <li>Introduzione all'ereditariet&agrave; in C++</li>
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:
<ul>
  <li> Dichiarazione di classi derivate</li>
  <li> Parte protetta di una classe</li>
  <li> Tipi di derivazione
       (<a href="lez01/esered1.cpp">Es. su tipi di derivazione</a>,
       <a href="lez01/parametricompatibili.cpp">Es. derivazione privata</a>) </li>
  <li> Ridefinizione di funzioni e dati (<a href="lez01/overloading.cpp">Es. su mascheramento basato su nome</a>)</li>
</ul>

<li> <b> Esercizi proposti</b>
<ul>
  <li> Realizzazione del tipo astratto Pila e Coda</li>
</ul>
</ul>
</ul>

<hr><a NAME="Gio1"></a>
<ul>
<li>
<b>Lezioni 4,5 - 13/1/00</b></li>

     <ul>
       <li> <b> Argomenti trattati</b>  [T1, Cap. 5, parr. 5.5 e 5.6]
            <ul>
              <li> Costruttori e distruttori ed ereditariet&agrave;
              <li> Costruttori di copia ed ereditariet&agrave;
                   (<a href="lez02/costcopiadefault.cpp">Es. costuttore di copia gratis</a>,
                   <a href="lez02/costcopia.cpp">Es. ridefinizione del costruttore di copia</a>)
              <li> Assegnazione ed ereditariet&agrave;
                   (<a href="lez02/assegnazionedefault.cpp">Es. costuttore di copia gratis</a>,
                   <a href="lez02/assegnazione.cpp">Es. ridefinizione del costruttore di copia</a>)
 
              <li> Ereditariet&agrave; multipla
            </ul>
       <li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:
            <ul>
              <li> Quando e come ridefinire funzioni in una classe derivata: costruttori, distruttori, costruttori di copia, assegnazione.
            </ul>
     </ul>
</ul>

<hr>
<ul><a NAME="Ven1"></a>
<li>
<b>Lezioni 6,7 - 14/1/00</b></li>

<ul>
  <li><b>Argomenti trattati</b>  [T1, Cap. 5, parr. 5.7, 5.8, 5.9]</li>

<ul>
  <li> Realizzazione struttura dati Pila in C++
       (<a href="lez03/pila">pila realiz. con record e punt</a>,
       <a href="lez03/pila/template">versione template</a>)

  <li> Realizzazione struttura dati Coda in C++
       (<a href="lez03/coda/coda1">coda realiz. con record e punt</a>,
       <a href="lez03/coda/coda2">coda realiz. con array "circolare"</a>)

  <li> Funzioni virtuali
       (<a href="lez03/virtual.cpp">funzione virtuale</a>,
       <a href="lez03/virtual-distr.cpp">distruttore virtuale</a>)
  <li> Classi base astratte
       (<a href="lez03/abstract.cpp">classe base astratta</a>,
       <a href="lez03/figure.cpp">figure</a>)
  <li> Derivazione e template
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li>Realizzare classi per strutture dati semplici
  <li>Quando e come usare le funzioni virtuali
</ul>

<li> <b> Esercizi proposti</b>
     <ul>
       <li><a href="lez03/esered2.cpp">Esercizio (appello Fond II laurea del 1/07/1998)</a></li>
       <li><a href="lez03/esered3.cpp">Esercizio (appello Fond II laurea del 5/7/1997)</a></li>
     </ul>
</ul>
</ul>


<hr>
<ul><a NAME="Gio2"></a>
<li>
<b>Lezioni 8,9 - 20/1/00</b></li>

<ul>
  <li><b>Argomenti trattati</b>  [T1, Cap. 13, parr. 13.1, 13.2 (escluso 13.2.2)]</li>

<ul>
  <li> Usi dell'&agrave; nella realizzazione di tipi astratti
       <ul>
         <li>realizzazione ISA tra tipi astratti
         <li>raffinamento della rappresentazione
         <li>supporto alla rappresentazione dei valori
       </ul>
  <li> Approfondimento della realizzazione della relazione ISA
       <li>realizzazione ISA:
            es. classi <a href="lez04/Persona.h">Persona</a> e <a href="lez04/PersonaSposata.h">PersonaSposata</a>
       <li>generalizzazione completa: es. docenti universitari
            (<a href="lez04/ISA/specifica.txt">specifica</a>,
            <a href="lez04/ISA">soluzione</a>)
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li>Come si realizza la relazione ISA
</ul>

<li> <b> Esercizi proposti</b>
     <ul>
       <li> Completare esempio docenti universitari
     </ul>
</ul>
</ul>

<hr>
<ul><a NAME="Ven2"></a>
<li>
<b>Lezioni 10,11 - 21/1/00</b></li>

<ul>
  <li><b>Argomenti trattati</b>  [T1, Cap. 13, parr. 13.3, 13.4, 13.5]</li>

<ul>
  <li>Ereditariet&agrave; e raffinamento della rappresentazione<br>
       <i>("ISA tra classi C++ che rappresentano lo stesso Tipo Astratto")</i>
       <ul>
         <li> uso di classi basi astratte:
              <a href="lez05/GrafoAstratta">es. grafo </a>
       </ul>
  <li>Ereditariet&agrave; e supporto alla rappresentazione dei valori
       <ul>
         <li>il metodo della delegation:
              <a href="lez05/PilaDelegation">es. pila realizzata
              per delegation con vettore estendibile</a>
       </ul>
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li>Come si usa l'ereditariet&agrave;
       per il raffinamento della rappresentazione:
       uso di classi base astratte
  <li>Come si usa l'ereditariet&agrave;
       per il supporto alla rappresentazione dei valori del TA:
       il metodo della delegation
</ul>

<li> <b> Esercizi proposti</b>
     <ul>
       <li> Completare esempio grafo, realizzando classe grafo con matrice di adiacenza e con lista di successori
       <li> Tutti gli esercizi sull'ereditariet&agrave; dati
            all'esame di Fond. II - laurea (<a href="http://tibur.dis.uniroma1.it/program/fondii/laurea/appelli/">appelli laurea</a>)
     </ul>
</ul>
</ul>


<hr>
<ul><a NAME="Mar3"></a>
<li>
<b>Lezioni 12,13,14 - 25/1/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> [T1, parr. 8.1-8.4]

<ul>
  <li> Introduzione alla complessit&agrave;
  <li> Modello di macchina astratto
  <li> Configurazione dell'input pi&ugrave; sfavorevole (caso peggiore)
  <li> Valutazione della complessit&agrave; come funzione della dimemsione
       dell'input
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> I tre aspetti fondamentali da cui astrarre per derivare
       un metodo per caratterizzare la complessit&agrave; di un algoritmo
  <li> Modello di macchina astratta
  <li> Criteri per la scelta del parametro che caratterizza la dimensione
       dei dati di ingresso
</ul>
</ul>
</ul>


<hr>
<ul><a NAME="Gio3"></a>
<li>
<b>Lezioni 15,16 - 27/1/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> [T1, parr. 8.5, 8.6, 8.8]

<ul>
  <li> Notazione O e Omega
  <li> Metodi per il calcolo della complessit&agrave;
  <li> Complessit&agrave; rispetto allo spazio
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Metodi per valutare la complessit&agrave;
  <li> Nozione di operazione dominante
  <li> Calcolare complessit&agrave; rispetto allo spazio

</ul>
</ul>
</ul>


<hr>
<ul><a NAME="Ven3"></a>
<li>
<b>Lezioni 17,18 - 28/1/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> [T1, parr. 8.7]

<ul>
  <li> Complessit&agrave; di un problema
  <li> Classi di complessit&agrave; (cenni)
  <li> Computabilit&agrave; (cenni)
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Cosa sono le delimatazioni superiore ed inferiore della
       complessit&agrave; di un problema
  <li> Avere una idea delle classi di complessit&agrave;
  <li> Sapere che esistono funzioni non calcolabili e problemi indecidibili
</ul>
<li> <b> Esercizi proposti</b>
     <ul>
       <li> Tutti gli esercizi sulla complessit&agrave; dati
            all'esame di Fond. II - laurea (<a href="http://tibur.dis.uniroma1.it/program/fondii/laurea/appelli/">appelli laurea</a>)
     </ul>
</ul>
</ul>


<hr>
<ul><a NAME="Mar4"></a>
<li>
<b>Lezioni 19,20,21 - 1/2/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> [T2, cap. 11, T2 cap. 7]

<ul>
  <li> Coda di priorit&agrave;
  <li> Heap
  <li> Realizzazione di heap con array
       (<a href="lez09"><code>heap.h</code> e <code>heap.cpp</code></a>)
  <li> Realizzazione Coda di Priorita con Heap
       (<a href="lez09"><code>coda_priorita.h</code></a>)
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Quali sono le operazioni fondamentali di un heap (incluse FaiScendere e FaiSalire) e la loro complessit&agrave;
  <li> Come realizzare Code di Priorit&agrave; usando heap
</ul>
<li> <b> Esercizi proposti</b>
     <ul>
       <li> Introdurre nel tipo astratto Coda di Priorit&agrave; le operazioni:
            <code>Elimina</code> i-esimo elemento; <code>CampiaPriorita</code> dell'i-esimo elemento assegnandogli un nuovo valore. Realizzare dette operationi (<a href="lez09/coda_priorita2">soluzione</a>)
     </ul>
</ul>
</ul>




<hr>
<ul><a NAME="Gio4"></a>
<li>
<b>Lezioni 22,23 - 3/2/00 - in laboratorio</b> </li>

<ul>
  <li><b>Argomenti trattati</b> [T1, parr. 10 e 14]

<ul>
  <li> Alberi n-ari, visita in preordine ed in postordine
  <li> Rappresentazione tramite liste e tramite alberi
  <li> Tipo astratto <code>Albero</code>
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Conoscere alberi n-ari e loro rappresentazione
  <li> Realizzare il tipo astratto albero n-ario in C++
</ul>
<li> <b> Esercizi proposti</b>
     <ul>
       <li> Esercizio su alberi n-ari
        (<a href="lez10">testo e soluzione</a>)
       <li> Realizzare esercizio proposto reppresntando alberi n-ari con alberi binari
     </ul>
</ul>
</ul>


<hr>
<ul><a NAME="Ven4"></a>
<li>
<b>Lezioni 24,25 - 4/2/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> [T2, cap. 11, T3 cap. 7]

<ul>
  <li> SelectionSort - alg. per l'ordinamento O(n^2)
  <li> HeapSort (facendo uso di un heap ausiliario) - alg. per l'ordinamento O(n log n) (<a href="lez11/heapsort"><code>heapsort</code></a>)
  <li> Delimitazione inferiore della complessit&agrave; del problema dell'ordinamento Omega(n log n)
  <li> Costruzione di un heap a partire da un array in tempo O(n)
       (<a href="lez11/heapsortAdvanced/buildheap.cpp"><code>BuildHeap.cpp</code></a>)

  <li> HeapSort non facendo uso di un heap ausiliaro
       (<a href="lez11/heapsortAdvanced/heapsort.cpp"><code>BuildHeap.cpp</code></a>)
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Delimitazione inferiore della complessit&agrave;
       del problema dell'ordinamiento
  <li> HeapSort
</ul>
<li> <b> Esercizi proposti</b>
     <ul>
       <li> Realizzare in C++ <code>HeapSort</code> senza fare uso di heap
            (<a href="lez11/heapsortAdvanced"><code>soluzione</code></a>)
     </ul>
</ul>
</ul>


<hr>
<ul><a NAME="Mar5"></a>
<li>
<b>Lezioni 26,27,28 - 8/2/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> [T2, cap. 12, T3 cap. 13]

<ul>
  <li> Dizionari
  <li> Alberi di ricerca
  <li> Inserimento e cancellazione da alberi di ricerca
  <li> Operazioni dei dizionari su alberi di ricerca
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Quali sono le operazioni fondamentali di un albero di ricerca e
       la loro complessit&agrave;
  <li> Come i dizionari possono essere basati su alberi di ricerca
</ul>
</ul>
</ul>




<hr>
<ul><a NAME="Gio5"></a>
<li>
<b>Lezioni 29,30 - 10/2/00 </b> </li>

<ul>
  <li><b>Argomenti trattati</b> [T2, cap. 12, T3 cap. 13]

<ul>
  <li> Tipi Astratti per le stutture dati Albero Binario e Albero di Ricerca
       (astrazioni d'entit&agrave;)
  <li> Realizzazione Albero Binario con figli in sharing
       (<a href="lez12"><code>AlbBin.h, AlbBin.cpp</code></a>)
  <li> Realizzazione Albero di Ricerca derivato da Albero Binario
       (<a href="lez12"><code>AlbRic.h, AlbRic.cpp</code></a>)
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Avere compreso esattamente le realizzazioni proposte,
       in particolare come esse usano lo sharing per mantenere
       la complessit&agrave; asintotica studiata,
       e perch&agrave; questo non pregiudica la correttezza della realizzazione

  <li> Sapere concettualizzare le strutture dati Albero Binario e
       Albero di Ricerca utilizzando astrazione d'entit&agrave;

  <li> Sapere realizzare Albero Binario e Albero di Ricerca in C++
</ul>
</ul>
</ul>


<hr>
<ul><a NAME="Ven5"></a>
<li>
<b>Lezioni 30,31 - 11/2/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> [T2, cap. 12]

<ul>
  <li> Realizzazione del tipo astratto Dizionario utilizzando
       la classe <code>AlbRic</code>
       (<a href="lez12"><code>Dizionario.h, Dizionario.cpp</code></a>)
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Come affrontare realizzazioni di tipi astratti utilizzando
       strutture di dati avanzate
</ul>
<li> <b> Esercizi proposti</b>
     <ul>
       <li> Completare la realizzazione di Dizionario (<a href="lez12">soluzione</a>)
     </ul>
</ul>
</ul>

<hr>
<ul><a NAME="Mar6"></a>
<li>
<b>Lezioni 33,34,35 - 15/2/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> [T2, cap. 12]

<ul>
  <li> Alberi AVL
  <li> Profondit&agrave; di alberi AVL: O(log n)
  <li> Bilanciamento: rotazioneSS, rotazione SD, rotazioneDD, rotazioneDS
  <li> Inserimento e cancellazione
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Come ribilanciare albero AVL: rotazioni
  <li> Quando ribilanciare albero AVL durante inserimento e cancellazione
  <li> La profondit&agrave; di un albero AVL
       e la complessit&agrave; dell'inserimento e cancellazione
</ul>
</ul>
</ul>




<hr>
<ul><a NAME="Gio6"></a>
<li>
<b>Lezioni 36,37 - 17/2/00 </b> </li>

<ul>
  <li><b>Argomenti trattati</b> [T2, cap. 12]

<ul>
  <li> Tipi Astratti per le stutture dati Albero AVL utilizzando
       realizzazione Albero Binario
       (astrazioni d'entit&agrave;)
  <li> Realizzazione Albero AVL derivato da Albero Binario
       (<a href="lez14"><code>AlbAVL.h, AlbAVL.cpp</code></a>)
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Avere compreso esattamente le realizzazioni proposte,
       in particolare in quali punti la realizzazione di albero AVL
       differisce dalla realizzazione di Albero di Ricerca

  <li> Sapere realizzare Albero AVL in C++
</ul>
<li> <b> Esercizi proposti</b>
     <ul>
       <li> Realizzazione del tipo astratto Dizionario utilizzando
            la classe <code>AlbAVL</code>
            (<a href="lez14">soluzione</a>)
     </ul>
</ul>
</ul>


<hr>
<ul><a NAME="Ven6"></a>
<li>
<b>Lezioni 38,39 - 18/2/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> Esercizio d'esame su strutture dati

<ul>
  <li> Realizzazione del tipo astratto Prestiti facedo uso di opportune strutture dati al fine di ottenere la massima efficienza delle operazioni
       (<a href="lez15/testo.txt">Testo</a>) </ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Come affrontare realizzazioni di tipi astratti utilizzando
       strutture di dati avanzate
</ul>
<li> <b> Esercizi proposti</b>
     <ul>
       <li> Completare la realizzazione di Prestiti (<a href="lez15">soluzione</a>)
     </ul>
</ul>
</ul>

<hr>
<ul><a NAME="Mar7"></a>
<li>
<b>Lezioni 40,41,42 - 22/2/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> [T3, cap. 12]

<ul>
  <li> Tavole Hash
  <li> Funzioni di Hashing su interi (K mod dimTavola).
       Nota la scelta di dimTavola &egrave; critica:
       <ul>
         <li> cattive scelte: potenze di 10, potenze di 2
         <li> buone scelte: numeri dispari, numeri primi (migliore)
       </ul>
  <li> Funzioni di Hashing su altri tipi di dato:
       <ul>
         <li>Trasformare la chiave in un intero
              <ul> <li> Reali: es. sommare mantissa ed esponente come interi
                   <li> Oggetti (astrazione d'entit&agrave;): es. considerare
                        indirizzo come un intero
                        (nota, solo se oggetti distinti rappresentano entit&agrave;
                        distinte)
                   <li> Stringhe: es. sommare codice ASCII dei caratteri
   (<a href="lez16/HashingStringhe.cpp"><code>HashingStringhe.cpp</code></a>)
                 </ul>
         <li>Usare funzione di hashing su interi
       </ul>
  <li> Fattore di carico
  <li> Gestione delle collisioni per concatenazione, usando
liste di trabocco (soluzione pi&ugrave; usata)
  <li> Analisi complessit&agrave; nel caso peggiore e nel caso medio
       (solo caso ricerca senza successo con liste di trabocco)
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Come progettare una Tavola Hash
  <li> Come realizzare Tavole Hash in C++.
</ul>
<li> <b> Esercizi proposti</b>
     <ul>
       <li> Realizzazione del tipo astratto Tavola Hash
     </ul>
</ul>
</ul>




<hr>
<ul><a NAME="Gio7"></a>
<li>
<b>Lezioni 43,44 - 24/2/00 </b> </li>

<ul>
  <li><b>Argomenti trattati</b> [T3, cap. 12]

<ul>
  <li> Hashing aperto (gestire le collisioni nella tavola hash stessa senza uso di liste di trabocco). Risparmio in spazio ma accesso pi&ugrave; lento.
  <li> Scansione Lineare
       (<a href="lez16/ScansioneLineare.pseudocpp"><code>pseudocodice</code></a>),
       fenomeno del clustering primario
  <li> Scansione Quadratica
       (<a href="lez16/ScansioneQuadratica.pseudocpp"><code>pseudocodice</code></a>),
       evita clustering primario, ma non clustering secondario
  <li> Doppio Hashing
       (<a href="lez16/DoppioHashing.pseudocpp"><code>pseudocodice</code></a>),
       evita clustering primario e secondario
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Conoscere metodi di scansione
       <li> Avere compreso perch&eacute; si guadagna in termini di spazio
            ma si perde in termini di tempo
</ul>
</ul>
</ul>


<hr>
<ul><a NAME="Ven7"></a>
<li>
<b>Lezioni 45,46 - 25/2/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> [T1 cap. 19]

<ul>
  <li> Tecnica algoritmica Divide et Impera
  <li> MergeSort
       (<a href="lez17/MergeSort.h"><code>MergeSort</code></a>)
       <li> Equazione di ricorrenza del MergeSort.
       <li> Metodo delle sostituzioni successive
            per risolvere eq. ricorrenza,
            es. soluzione eq. ricorrenza del MergeSort
       <li> Equazione di ricorrenza generale per Divide et Impera
       <li> Teorema sulla soluzione delle eq. ricorrenza Divide et Impera
</ul>
<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Conoscere la tecnica divide et impera
  <li> Saper risolvere semplici eq. ricorrenza attraverso
       il metodo delle sostituzioni
  <li> MergeSort

</ul>
<li> <b> Esercizi proposti</b>
     <ul>
       <li> Utilizzare Divide et Impera per realizzare un algoritmo per il
calcolo del minimo e del massimo di un vettore di interi non ordinato
(soluzione, vedere T1, cap 19)
     </ul>
</ul>
</ul>



<hr>
<ul><a NAME="Mar8"></a>
<li>
<b>Lezioni 47,48,49 - 29/2/00 </b> </li>

<ul>
  <li><b>Argomenti trattati</b> [T1, cap. 18]

<ul>
  <li> Tecnica algoritmica Greedy (o Golosa)
  <li> Problemi di ottimizzazione, ottimo globale
  <li> Spazio di ricerca, esplorazione dello spazio di ricerca
  <li> Tecnica Greedy: evita l'esplorazione dello spazio di ricerca,
       ottiene un ottimo "locale" che in certe circostanze &egrave;
       anche un ottimo globale
  <li> Considerazioni sulla complessit&agrave; della tecnica greedy
  <li> Problema del resto [T1, Es. 18.9]
  <li> Problema della bisaccia
  <li> Realizzazione in C++: Algoritmi generici
  <ul>
    <li> Classe esploratore greedy
         (<a href="lez17/esp-greedy.h"><code>esp-greedy.h</code></a>)
    <li> Algoritmo generico greedy
         (<a href="lez17/esp-greedy.cpp"><code>esp-greedy.cpp</code></a>)
  </ul>
  <li> Algoritmo greedy per problema della bisaccia basato sul algoritmo
generico
       <code>Greedy</code>
       (<a href="lez17"><code>greedy-bisaccia</code></a>)
</ul>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Conoscere la tecnica greedy
  <li> Avere compreso a fondo l'algoritmo generico <code>Greedy</code>
</ul>
<li> <b> Esercizi proposti</b>
     <ul>
       <li> Realizzare soluzione greedy per problema del resto
            facendo uso dell'algoritmo generico <code>Greedy</code>
            (<a href="lez17"><code>greedy-monete</code></a>)
     </ul>
</ul>
</ul>


<hr>
<ul><a NAME="Gio8"></a>
<li>
<b>Lezioni 50,51 - 2/3/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> [T1 cap. 18]

<ul>
  <li> Applicabilit&agrave; della tecnica greedy:
       propriet&agrave; della scelta greedy e propriet&agrave; della sottostruttura ottima
  <li> Problema della risorsa
  <li> Realizzazione della soluzione greedy per problema della risorsa
       facendo uso dell'algoritmo generico <code>Greedy</code>
       (<a href="lez17"><code>greedy-risorsa</code></a>)
</ul>
<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Sapere realizzare soluzioni greedy per problemi di ottimizzazione
       facendo uso dell'algoritmo generico <code>Greedy</code>

</ul>
</ul>
</ul>

<hr>
<ul><a NAME="Gio9"></a>
<li>
<b>Lezioni 52,53 - 9/3/00 </b> </li>

<ul>
  <li><b>Argomenti trattati</b> [T3, cap. 23]

<ul>
  <li> Grafi
       <ul>
         <li> rappresentazione con liste di successori (ripasso)
         <li> rappresentazione con matrici di adiacenza (ripasso)
       </ul>
  <li> Visita in Ampiezza (BFS)
  <li> Struttura della visita in ampiezza:
       <ul>
         <li> inizio visita
         <li> previsita del nodo (il nodo diviene grigio)
         <li> postvisita del nodo (il nodo diviene nero)
         <li> fine visita
       </ul>
  <li> Costo della visita in ampiezza:
       <ul>
         <li> O(num_nodi + num_archi), se rappresento grafi con liste di successori
         <li> O(num_nodi^2), se rappresento grafi con matrici di adiacenza
       </ul>
  <li> Iteratori: un modo efficiente per realizzare in C++ la scansione di collezioni.
  <li> Realizzazione in C++ della <a href="lez18">visita in ampiezza</a>
<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Avere compreso la struttura della visita in ampiezza
  <li> Conoscere la sua complessit&agrave;
  <li> Sapere realizzare in C++ la visita in ampiezza in modo efficiente utilizzando gli iteratori per scadire i successori di un nodo
</ul>
</ul>
</ul>
</ul>


<hr>
<ul><a NAME="Ven9"></a>
<li>
<b>Lezioni 54,55 - 10/3/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> [T3, cap. 23]

<ul>
  <li> Grafi
  <li> Visita in profondit&agrave; (DFS): versione non ricorsiva (usando una pila)
  <li> Visita in profondit&agrave; (DFS): versione definitiva (ricorsiva)
  <li> Struttura della visita in profondit&agrave;:
       <ul>
         <li> inizio visita
         <li> previsita del nodo (il nodo diviene grigio)
         <li> postvisita del nodo (il nodo diviene nero)
         <li> fine visita
       </ul>
       Nota: quando la visita di un nodo termina (il nodo diviene nero) la
visita dei suoi successori non solo &egrave; gi&agrave; iniziata ma &egrave;
gi&agrave; terminata (solo per visita ricorsiva)!
  <li> Costo della visita in profondit&agrave;:
       <ul>
         <li> O(num_nodi + num_archi), se rappresento grafi con liste di successori
         <li> O(num_nodi^2), se rappresento grafi con matrici di adiacenza
       </ul>
  <li> Realizzazione in C++ della <a href="lez18">visita in profondit&agrave</a>

<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Avere compreso la struttura della visita in profondit&agrave;
  <li> Conoscere la sua complessit&agrave;
  <li> Sapere realizzare in C++ la visita in profonodit&agrave; in modo
efficiente utilizzando gli iteratori per scadire i successori di un nodo </ul>
</ul>
</ul>
</ul>

<hr>
<ul><a NAME="Mar10"></a>
<li>
<b>Lezioni 56,57,58 - 14/3/00 </b> </li>

<ul>
  <li><b>Argomenti trattati</b> [T3, cap. 23]

<ul>
  <li> Uso di visita in ampiezza [BFS] e visita in profondit&agrave; [DFS] per
risolvere diversi problemi su grafi:
       <ul>
         <li> Calcolo della distanza da un nodo <code>rad</code> [BFS]
         <li> Calcolo dei cammini minimi
              per raggiungere tutti i nodi da <code>rad</code>
              (calcolo del vettore dei predecessori) [BFS]
         <li> Raggiungibilit&agrave; di un dato nodo da <code>rad</code> [DFS/BFS]
         <li> Calcolo di un cammino tra <code>rad</code> ed un dato nodo [DFS/BFS]
         <li> Calcolo della chiusura transitiva di un grafo (uso num_nodi volte [BFS/DFS])
         <li> Realizzazione in C++ (<a href="lez19">codice</a>)
       </ul>

  <li> Grafi diretti aciclici (DAG)
  <li> Ordinamento topologico di un DAG
  <li> Algoritmo che calcola l'ordinamento topologico di un grafo, se
            il grafo &egrave; un DAG, oppure mette in evidenza che un grafo non &egrave;
            un DAG.
  <li> Realizzazione in C++ (<a href="lez19">codice</a>)

</ul>
  <li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>
<ul>
  <li> Sapere come modificare visita in ampiezza e visita in profondit&agrave; per risolvere problemi relativi ai grafi
  <li> Sapere cosa &egrave; un grafo aciclico
  <li> Avere compreso a fondo l'algoritmo per il calcolo dell'ordine topologico
</ul>
<li> <b> Esercizi proposti</b>
     <ul>
       <li> Svilippare un algoritmo di visita in ampiezza e
            profondit&agrave; generico che si appoggino ad
            opportune classi <code>esploratore</code>
            (<a href="lez19/Esp_BFS_DFS">soluzione</a>)
     </ul>
</ul>
</ul>


<hr>
<ul><a NAME="Gio10"></a>
<li>
<b>Lezioni 59,60 - 16/3/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> [T3 cap. 25.1 (no teoremi), 25.2]

<ul>
  <li> Grafi con pesi (non negativi) sugli archi
  <li> Rappresentazioni di grafi con pesi sugli archi
       <ul>
         <li> liste di successori: inserendo campo ausiliario nei recod della lista dove memorizzare il peso dell'arco
         <li> matrici di adiacenza: memorizzando i pesi nella matrice
         <li> usando una tavola hash separata per mantenere i pesi degli archi
       </ul>
  <li> Algoritmo di Dijkstra
       <ul>
         <li> idea intuitiva
         <li> analisi della correttezza
         <li> analisi di complessit&agrave;
              <ul>
                <li> mantenendo le distanze in un vettore non ordinato O(num_nodi^2)
                <li> mantenendo i nodi da visitare in un heap ordinato secondo le distanze
                     O((num_nodi+num_archi)*log num_nodi)
              </ul>
         <li> algoritmo di Dijkstra &egrave; un algoritmo greedy
       </ul>
</ul>
<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> Conoscere in modo approfondito l'algoritmo di Dijkstra
</ul>

<li> <b> Esercizi proposti</b>
     <ul>
       <li> Realizzare l'algoritmo di Dijkstra
       facendo uso dell'algoritmo generico <code>Greedy</code>
     </ul>
</ul>
</ul>

<hr>
<ul><a NAME="Ven10"></a>
<li>
<b>Lezioni 61,62 - 17/3/00</b></li>

<ul>
  <li><b>Argomenti trattati</b> [T3 cap. 26.2, 16 introduzione]

<ul>
  <li> Algoritmo di Floyd-Warshall per calcolare le distanze minime tra tutti i nodi di un grafo con pesi sugli archi
       <ul>
         <li> Osservazione sulla possibilit&agrave; di strutturare un cammino minimo che passa in per i nodi {0,..,k} in uno o due cammini che passano per i nodi {0,..,k-1}
         <li> Algoritmo per calcolare le distanze minime tra tutti i nodi di un grafo con pesi sugli archi, che usa un algoritmo ricorsivo per calcolare il cammino minimo tra due nodi basato sull'osservazione precedente. Costo di tale algoritmo: esponenziale!
         <li> Calcolare la solizione bottom-up: ottengo l'algoritmo di Floyd-Warshall
       </ul>
       <li> analisi della complessit&agrave; dell'algoritmo di Floyd-Warshall: O(num_nodi^3)
     <li> L'algoritmo di Floyd-Warshall &egrave; basato sulla Programmazione Dinamica
     <li> Concetti base della Programmazione Dinamica: dividere il problema in modo ricorsivo,
          calcolare la soluzione bottom-up usando tavole.
</ul>
<li><b>Cosa lo studente dovrebbe sapere dopo la lezione</b>:</li>

<ul>
  <li> L'algoritmo di Floyd-Warshall. Come modificarlo per ottenere i cammini minimi tra tutti i nodi e per ottenere la chiusura transitiva di un grafo.
  <li> I concetti base della Programmazione Dinamica
</ul>
</ul>
</ul>

<hr>
<ul><a NAME="Es11"></a>
<li>
<b>Esercizi d'esame - 21/3/00, 23/3/00, 24/3/00</b></li>

<ul>
  <li><b>Esempi prima parte (parte progettuale)</b>

<ul>
  <li> GestoreProcessi (Code di Priorit&agrave;, Heap):
       <a href="lez20/es1/testo.html">testo</a>,
       <a href="lez20/es1/sol1">soluzione</a>
       (<a href="lez20/es1/sol2">soluzione con locator</a>)

  <li> VisitaMuseo (Algoritmi su Grafi):
       <a href="lez20/es2/testo.txt">testo</a>,
       <a href="lez20/es2">soluzione</a>

  <li> Provider (Algoritmo Generico Greedy):
       <a href="lez20/es3/testo.html">testo</a>,
       <a href="lez20/es3">soluzione</a>

  <li> Deposito (Tavole Hash):
       <a href="lez20/es4/testo.html">testo</a>,
       <a href="lez20/es4">soluzione</a>

  <li> DepositoOggetti (Dizionari, Alberi AVL):
       <a href="lez20/es5/testo.html">testo</a>,
       <a href="lez20/es5">soluzione</a>
  <li> Prestiti (Dizionari, Alberi AVL - oppure Tavole Hash)
       Si veda <a href="#Ven6">Lez 38,39</a>
</ul>
<li><b>Esempi seconda parte (domanda sul programma)</b>:</li>

<ul>
  <li> Tutti gli esercizi sull'ereditariet&agrave; dati
       all'esame di Fond. II - laurea
       (<a href="http://tibur.dis.uniroma1.it/program/fondii/laurea/appelli/">appelli laurea</a>)

  <li> Tutti gli esercizi sulla complessit&agrave; dati
            all'esame di Fond. II - laurea (<a href="http://tibur.dis.uniroma1.it/program/fondii/laurea/appelli/">appelli laurea</a>)

  <li> Domande pi&ugrave; teoriche, ad esempio:
       <ul>
         <li> illustrare su un esempio la tecnica Divide et Impera (MergeSort)
         <li> illustrare la tecnica di programmazione dinamica (Floyd-WarShall)
         <li> illustrare l'alg. di inserimento in un albero di ricerca
         <li> illustrare, con un esempio, il concetto di rotazione per
              mantenere bilanciato un alb. AVL
         <li> ecc.
       </ul>

</ul>
</ul>
</ul>
</ul>

<hr><font size=-1>Home page del <a href="index.html">Corso
di Fondamenti di Informatica II - secondo modulo</a></font>
<br><font size=-1>del Diploma Universitario in Ingegneria Informatica dell'Universit&agrave;
di Roma "La Sapienza"</font>
</body>
</html>
