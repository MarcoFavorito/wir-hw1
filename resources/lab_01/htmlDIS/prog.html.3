<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head>  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">  <title>PROGRAMMA DEL CORSO</title></head><body><div style="text-align: center;"><b><u><font color="#3366ff"><font size="+3">Programma del corso (A. A. 2003/2004)<span style="text-decoration: underline;"><span style="text-decoration: underline;"><span style="text-decoration: underline;"><span style="text-decoration: underline;"></span></span></span><br></span></font></font></u></b></div><p style="text-align: center;">Il programma e' disponibile anche informato <a href="prog.doc">.doc</a> e <a href="prog.pdf">.pdf</a></p><p><span style="text-decoration: underline;">Testo adottato</span>: R.Sedgewick. Algoritmi in Java. Addison-Wesley</p><p><span style="text-decoration: underline;">Note</span><br></p><ul>  <li>5.1 - 5.4 significa dal paragrafo 5.1 al paragrafo 5.4, estremiinclusi, e <span style="text-decoration: underline;">non</span> 5.1 e 5.4</li>  <li>Il testo si intende integrato dal materiale distribuito daldocente: slide, appunti, esercizi ed esercitazioni svolti dal docente,disponibili on-line</li></ul><p>1. Introduzione. Algoritmi e strutture dati: esempi e uso. Tipiastratti. Qualit&agrave; di algoritmi e strutture dati.<br>- Capitolo 1 (lettura)<br></p><p>2. Efficienza. Efficienza spaziale e temporale. Misuradell&#8217;efficienza temporale: obiettivi. Modello di costo RAM. Analisi delcaso peggiore e istruzione dominante. Complessit&agrave; asintotica.Primi esempi: calcolo della complessit&agrave; di Insertion Sort.Equazioni di ricorrenza. Metodo di sostituzione per la soluzione diequazioni di ricorrenza. Metodo Divide et Impera. Algoritmo Merge Sort ecalcolo della sua complessit&agrave;. <br>- Capitolo 2 fino al par. 2.6 (incluso)<br>- Par. 6.4<br>- Capitolo 8 fino al par. 8.3 (incluso)<br>- Par. 5.2 (fino al problema delle Torri di Hanoi escluso)<br>- Materiale distribuito dal docente<br>- Esercitazione svolta in laboratorio</p><p>3. Tipi di dato astratti e strutture dati elementari. Tipo di datoastratto. Tipi astratti elementari: liste, pile, code. Implementazionedi liste, pile e code mediante array e strutture collegate.Generalit&agrave; sulle classi Java che implementano le liste. <br>- Capitolo 3 (utile lettura di ripasso)<br>- Capitolo 4, introduzione, parr. 4.1-4.2, parr. 4.4-4.5, 4.7<br>- Documentazione Java sulle classi LinkedList, ArrayList e Vector<br>- Materiale distribuito dal docente<br></p><p>4. Algoritmi di ordinamento. Selection Sort. Complessit&agrave; delSelection Sort. Ordinamento di oggetti complessi. Quick Sort.Complessit&agrave; del Quick Sort nel caso peggiore e nel caso migliore.Alberi di decisione. Limite inferiore alla complessit&agrave; deglialgoritmi di ordinamento basati su confronti. <br>- Capitolo 6, introduzione, parr. 6.1-6.4, 6.6<br>- Capitolo 7 fino al par. 7.2 (incluso)<br>- Capitolo 8 fino al par. 8.3 (incluso)<br>- Materiale distribuito dal docente<br></p><p>5. Alberi. Tipo astratto albero. Rappresentazione di alberi construtture collegate. Rappresentazione di alberi in Java. Algoritmi perla visita di alberi. Alberi binari. Rappresentazione di alberi binari.Visita di alberi binari. Rappresentazione di alberi binari con array econ strutture collegate. <br>- Capitolo 5, parr. 5.4-5.7<br>- Per la rappresentazione mediante array: v. implementazione degli Heap<br>- Materiale distribuito dal docente<br></p><p>6. Introduzione ai dizionari. Il tipo astratto dizionario.Implementazione di dizionari con alberi. Alberi binari di ricerca.Definizioni e propriet&agrave;. Rappresentazione dei nodi di un alberobinario di ricerca. Operazioni sugli alberi binari di ricerca eimplementazione di alberi binari di ricerca. Algoritmo di ricerca e suacomplessit&agrave;. Inserimento in un albero binario di ricerca e suacomplessit&agrave;. Cancellazione da un albero binario di ricerca e suacomplessit&agrave;. <br>- Capitolo 12, introduzione e par. 12.1, parr. 12.6, 12.7 (non ledimostrazioni), 12.8, 12.9 (solo cancellazione)<br>- Materiale distribuito dal docente<br>- Esercitazione svolta in laboratorio </p><p>7. Dizionari e strutture dati bilanciate. Bilanciamento.Bilanciamento perfetto e bilanciamento in altezza, fattore dibilanciamento. Cenno agli alberi Alberi AVL. Calcolo dell'altezza dialberi bilanciati (binari e k-ari).<br>- Capitolo 13, introduzione<br>- Materiale distribuito dal docente<br></p><p>8. Dizionari su memoria secondaria e alberi B. Dizionari su memoriasecondaria. Modello di costo. B-tree: definizioni e propriet&agrave;.Calcolo dell&#8217;altezza di un B-tree nel caso migliore e peggiore. Ricercain un B-tree.<br>- Capitolo 16, introduzione, par. 16.2, par. 16.3 (solo definizione dialbero B, ricerca e proprieta' 16.2)<br>- Materiale distribuito dal docente<br></p>9. Hashing. Definizioni. Tabelle hash. Indirizzamento diretto. Funzionihash perfette. Funzioni hash non perfette e collisioni. Requisiti dellefunzioni hash. Tipi di funzioni hash. Risoluzione delle collisioni.Concatenazione e indirizzamento aperto. <br>- Capitolo 14, parr. 14.1, 14.2 (fino alla proprieta' 14.2 esclusa),14.3 (saltare la proprieta' 14.3), 14.4 fino alla proprieta' 14.4esclusa, 14.5 fino alla fine di pagina 644<br>- Materiale distribuito dal docente<br>- Esercitazione svolta in laboratorio<br><p>10. Heap. Definizioni e propriet&agrave;. Heap minimale e massimale.Operazioni sugli heap. Rappresentazione di heap. Rappresentazione conarray. Algoritmi su heap: estrazione del massimo, cancellazione delmassimo, inserimento, conversione di una array in un heap. Heap Sort. <br>- Capitolo 9, introduzione, 9.1-9.3, 9.4 fino alla proprieta' 9.6(esclusa)<br>- Materiale distribuito dal docente<br></p><p>11. Grafi. Definizioni. Rappresentazione di grafi con liste diadiacenza, matrici di incidenza, matrici di adiacenza. Vantaggi esvantaggi delle diverse rappresentazioni. Rappresentazione di grafi inJava. Visita adi un grafo. Visita in profondit&agrave; e suaimplementazione. Visita in ampiezza e sua implementazione. Il problemadei cammini minimi. Propriet&agrave; elementari dei cammini minimi.Algoritmo di Dijkstra e sua complessita'. <br>- Capitolo 5, parr. 5.4 e 5.8<br>- <a href="http://www.dis.uniroma1.it/%7Ebecchett/algo/slide/sedgewickch21.pdf">Capitoloaggiuntivo</a> in Inglese messo a disposizione da Pearson's Education <br>- Materiale distribuito dal docente<br></p></body></html>