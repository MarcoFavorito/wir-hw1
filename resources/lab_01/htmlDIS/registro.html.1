<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.72 [en] (X11; U; AIX 4.3) [Netscape]">
   <title>Registro Fondamenti di Informatica - Ing. Meccanica</title>
</head>
<body bgcolor="#FFFFFF">

<center><b><font size=+1>REGISTRO DELLE LEZIONI</font></b>
<br><b><font size=+1>Fondamenti di Informatica, Ing. Meccanica,</font></b>
<br><b><font size=+1>&nbsp;a.a. 2000/2001, "vecchio ordinamento"</font></b>
<br><i>docente: R. Beraldi</i></center>

<p><br>
<table BORDER COLS=3 WIDTH="100%" NOSAVE >
<tr>
<td WIDTH="10%">
<center><b>LEZIONE [GIORNO]&nbsp;</b></center>
</td>

<td>
<center><b>ARGOMENTO E RIFERIMENTI</b></center>
</td>

<td>
<center><b>COSA SI DOVREBBE SAPERE DOPO LA LEZIONE</b></center>
</td>
</tr>

<tr>
<td><b>1.</b> [28.02.01]</td>

<td>
<li>
Presentazione del corso</li>

<li>
La nozione di algoritmo</li>

<li>
Flow-chart e pseudo-codifica&nbsp;</li>

<br><a href="#L1">[1]</a> 1.1</td>

<td>
<li>
Struttura del corso e modalita' di esame</li>

<li>
Testi di riferimento&nbsp;</li>

<li>
Cosa e' un algoritmo</li>
</td>
</tr>

<tr>
<td><b>2.</b> [1.03.01]</td>

<td>
<li>
Esempi di algoritmi:</li>

<li>
Ricerca di un elemento in un insieme ordinato</li>

<li>
Ricerca di un elemento in un insieme</li>

<li>
Calcolo della somma dei primi N numeri naturali</li>

<br><a href="#L2">[2]</a> Cap. 1</td>

<td>
<li>
Le proprieta' di un algoritmo&nbsp;</li>

<li>
Uso dello pseducodice per descrivere semplici algoritmi</li>

<li>
La nozione di variabile</li>

<li>
Le strutture di controllo: sequenza, iterazione, decisione</li>
</td>
</tr>

<tr>
<td><b>3. </b>[5.03.01]</td>

<td>
<li>
Rappresentazione dell'infomazione: codifica dei naturali&nbsp;</li>

<li>
Cenni sull'architettura di Von Neumann: la CPU e la memoria&nbsp;</li>

<li>
<a href="#L1">[1]</a> 1.3, 2.3, 2.4, 14.1</li>
</td>

<td>
<li>
Come si rappresentano i numeri naturali</li>

<li>
Cosa e' la memoria principale</li>

<li>
Come e' organizzata&nbsp; la CPU</li>

<li>
Come avviene il prelievo delle istruzioni&nbsp;</li>

<li>
Come viene eseguita una istruzione</li>
</td>
</tr>

<tr>
<td><b>4. </b>[6.03.01]</td>

<td>
<li>
Esempio di esecuzione di un programma sulla macchina hardware</li>

<li>
Linguaggi assembler, macchina, ad alto livello</li>

<li>
Compilazione ed interpretazione</li>

<li>
Le fasi per lo sviluppo di un programma: editing, compilazione, debugging</li>

<br><a href="#L1">[1]</a> 1.4.2, 1.4.3, 1.5, 1.6, 1.7, 2.2</td>

<td>
<li>
Cosa &egrave; il linguaggio assembler</li>

<li>
Cosa &egrave; il linguaggio macchina</li>

<li>
Come avviene a livello di macchina hardware l'esecuzione di un programma</li>

<li>
Cosa sono i linguaggi ad alto livello</li>

<li>
La differenza fra compilazione ed interpretazione</li>
</td>
</tr>

<tr>
<td><b>5.&nbsp; </b>[7.03.01]</td>

<td>
<li>
Linguaggi di programmazione: sintassi e semantica</li>

<li>
Notazione EBNF e diagrammi sintattici</li>

<li>
Il linguaggio Pascal: struttura di un programma</li>

<br><a href="#L1">[1]</a>&nbsp; 3, 4.2</td>

<td>
<li>
Cosa e' un linguaggio formale</li>

<li>
Cosa e' una grammatica</li>

<li>
Come si leggono i diagrammi sintattici</li>

<li>
Come e' strutturato un programma Pascal</li>
</td>
</tr>

<tr>
<td><b>&nbsp;</b>[8.03.01]</td>

<td><b><i>PRIMA</i> ESERCITAZIONE AUTOGUIDATA</b></td>

<td>
<li>
Usare l'ambiente Windows&nbsp;</li>
</td>
</tr>

<tr>
<td><b>6.</b> [12.03.01]</td>

<td>
<li>
Rappresentazione dei&nbsp; relativi: codifica in complemento a 2</li>

<li>
Rappresentazione dei&nbsp; reali: codifica floating point, precisione</li>

<li>
<a href="#L1">[1]&nbsp;</a> 14.3.1, 14.3.2, 14.4.1, 14.4.2</li>
</td>

<td>
<li>
Caratteristiche delle rappresentazioni: overflow, underflow, precisione</li>
</td>
</tr>

<tr>
<td><b>7.</b> [13.03.01]</td>

<td>
<li>
Struttura e sintassi del linguaggio Pascal&nbsp;</li>

<li>
Tipi semplici, operatori aritmetici, logici, relazionali.</li>

<li>
Overloading e Coercion</li>

<li>
<a href="#L1">[1]</a> 4</li>
</td>

<td>
<li>
Cosa vuol dire correttezza sintattica</li>

<li>
Quale ruolo svolge la parte dichiarativa in un programma&nbsp;</li>

<li>
Quali sono i tipi semplici del linguaggio ed i&nbsp; relativi operatori</li>
</td>
</tr>

<tr>
<td><b>8.</b> [14.03.01]</td>

<td>Esempi di programmi: Conversione lettere&nbsp;</td>

<td>Come usare le istruzioni: read, write, assegnazione, if-then, while,
const</td>
</tr>

<tr>
<td>&nbsp;<i>15.03.01</i></td>

<td><b><i>SECONDA</i> ESERCITAZIONE AUTOGUIDATA</b></td>

<td></td>
</tr>

<tr>
<td><b>9</b>. [19.03.01]</td>

<td>
<li>
Esempi: somma numeri mediante for, repeat, while; conversione di base per
un numero intero mediante divisioni successive; metodo di Horner
<a href="#L1">[1]</a>
14.1 - 14.2 -14.3 - 14.4.1 - 14.4.2&nbsp;</li>
</td>

<td>
<li>
Come individuare nel problema uno&nbsp; uno schema di calcolo ripetitivo
e tradurlo in cicli&nbsp;</li>
</td>
</tr>

<tr>
<td><b>10</b>. [20.03.01]</td>

<td>
<li>
Esempi: conversione di un numero frazionario (prodotti successivi), calcolo
del MCD applicando la definizione&nbsp;</li>
</td>

<td>
<li>
Come usare while .. do , e repeat... until con due condizioni logiche e
sfruttare il teorema di De Morgan per passare da una struttura di controllo
ad un'altra.</li>
</td>
</tr>

<tr>
<td><b>11.</b> [21.03.01]</td>

<td>
<li>
Esempi: MCD (definizione), Calcolo del valore approssimato di EXP(x), ordinare
3 numeri, calcolo funzione spezzata</li>

<li>
Esercizi proposti: (a) Calcolo MCD mediante teoremi di Eulero, (b) tabulazione
della funzione spezzata</li>
</td>

<td>
<li>
Come sfruttare schemi di calcolo ripetitivi mediante cicli indefiniti</li>

<li>
Come usare istruzioni di selezione annidate&nbsp;</li>
</td>
</tr>

<tr>
<td><b>&nbsp;</b><i>22.03.01</i></td>

<td><b><i>TERZA</i> ESERCITAZIONE AUTOGUIDATA</b></td>

<td></td>
</tr>

<tr>
<td><b>12. </b>[26.03.01]</td>

<td>
<li>
Unita' di programma, scope e campo d'azione. Regole di visibilita' in Pascal
<a href="#L1">[1]</a>
8.1 - 8.2 - 8.3 - 8.7</li>
</td>

<td>
<li>
Come arganizzare un programma in Unita'</li>

<li>
Quale relazione esiste fra le unita'&nbsp;</li>

<li>
Come si attiva una unita': il meccanismoi di chiamata&nbsp;</li>
</td>
</tr>

<tr>
<td><b>13.</b> [27.03.01]</td>

<td>
<li>
Procedure, Funzioni: sitassi e semantica&nbsp;</li>

<li>
Passaggio dei parametri <a href="#L1">[1]</a> 8.4 - 8.5 - 8.6</li>

<li>
Effetti collaterali</li>
</td>

<td>
<li>
Caratteristiche delle procedure e delle funzioni e modalita' di legame
dei parametri formale ed attuale</li>

<li>
Cosa sono gli effetti collaterali</li>
</td>
</tr>

<tr>
<td><b>14.</b> [28.03.01]</td>

<td>
<li>
Record di Attivazione, catena statica, comportamento dinamico dello stack
<a href="#L1">[1]</a>&nbsp;
8.10</li>

<li>
Esempio di esecuzione di un programma con chiamate mutue e relativa evoluzione
dello stack <a href="#L1">[1]</a>&nbsp;</li>
</td>

<td>
<li>
Come viene realizzato il supporto per l'utilizzo delle unita' di programma</li>

<li>
Cosa e' e quali informazioni contiene il record di attivazione</li>

<li>
Cosa e' e a cosa serve la catena statica</li>
</td>
</tr>

<tr>
<td><b>15.</b> [29.03.01]</td>

<td>
<li>
Dati strutturati: il tipo astratto matrice ed il costruttore di tipo array&nbsp;</li>

<li>
Cenni sul ciclo di sviluppo del software, metodologia top-down <a href="#L1">[1]</a>
9.1, <a href="#L1">[2]</a> Cap. 1</li>
</td>

<td>
<li>
Cosa e' un tipo astratto</li>

<li>
Come usare il costruttore array per definire tipi di dato strutturato&nbsp;</li>
</td>
</tr>

<tr>
<td><b>16.&nbsp;</b> [02.04.01]</td>

<td>
<li>
Passaggio di parametri per i tipi array</li>

<li>
Compatibilita' fra tipi</li>

<li>
La nozione di file</li>
</td>

<td>
<li>
Cosa e' la compatibilita' basata sui nomi</li>

<li>
Cosa e' un file e come si usa in TurboPascal&nbsp;</li>
</td>
</tr>

<tr>
<td>03.04.01</td>

<td><b><i>QUARTA</i> ESERCITAZIONE AUTOGUIDATA</b></td>

<td></td>
</tr>

<tr>
<td><b>17.</b> [9.04.01]</td>

<td>
<li>
Esercizi sull'uso dei file</li>
</td>

<td>
<li>
Sapere utilizzare i file text</li>
</td>
</tr>

<tr>
<td><b>18.</b> [10.04.01]</td>

<td>
<li>
Esercizi che utilizzano array</li>
</td>

<td>
<li>
Come usare gli array</li>
</td>
</tr>

<tr>
<td><b>19.</b> [11.04.01]</td>

<td>
<li>
Ricorsione</li>
</td>

<td>
<li>
Cosa e' la ricorsione</li>

<li>
Come evolve lo stack</li>
</td>
</tr>

<tr>
<td><b>20.</b> [18.04.01]</td>

<td>
<li>
Esempi di applicazione della ricorsione: ricerca binaria ([<a href="#L1">2</a>]
3.3.6) ed attraversamento di una palude ([<a href="#L1">2</a>] 10.6)</li>
</td>

<td>
<li>
Come sfruttare la struttura del problema per derivare algoritmi ricorsivi&nbsp;</li>
</td>
</tr>

<tr>
<td>19.04.01</td>

<td><b><i>QUINTA</i> ESERCITAZIONE AUOTOGUIDATA</b></td>

<td></td>
</tr>

<tr>
<td><b>21.</b>&nbsp; [23.04.01]</td>

<td>
<li>
Cenni sulla complessita' computazionale. La notazione O(f(n))</li>

<li>
Limite asintotico alla complessita' delle ricerche sequenziale e binaria
(<a href="#L1">[1]</a> da 11.2 a 11.6)</li>
</td>

<td>
<li>
Come misurare l'efficienza degli algoritmi</li>

<li>
Significato della notazione O&nbsp;</li>

<li>
Calcolo della complessita' per programmi con cicli for semplici ed innestati</li>
</td>
</tr>

<tr>
<td><b>22.</b> [24.04.01]</td>

<td>
<li>
Il problema dell'ordinamento di un vettore: gli algoritmi Selection Sort
e Merge Sort (<a href="#L1">[1]</a>&nbsp; 13.1, 13.3;&nbsp; [<a href="#L1">2</a>]
3.4.3;9.1;9.2; 9.2.2)&nbsp;</li>
</td>

<td>
<li>
Conoscenza degli algoritmi selection sorrt e merge sort</li>

<li>
Come derivare la complessita' di tali algoritmi&nbsp;</li>
</td>
</tr>

<tr>
<td>26.04.01</td>

<td><b><i>SESTA </i>ESERCITAZIONE AUTOGUIDAT<i>A</i></b></td>

<td></td>
</tr>

<tr>
<td><b>23.</b> [30.04.01]</td>

<td>
<li>
Bubble sort,&nbsp;</li>

<li>
Tipo record, Il tipo Tabella [<a href="#L1">2</a>]&nbsp;</li>
</td>

<td>
<li>
Saper usare il tipo record. Operazione di gestione di una tabella</li>
</td>
</tr>

<tr>
<td><b>24.</b>&nbsp; [2.05.01]&nbsp;</td>

<td>
<li>
&nbsp;Puntatori, variabili dinamiche [<a href="#L1">2</a>]&nbsp;</li>
</td>

<td>
<li>
Cosa e' una variabile dinamica, cosa sono e come si usano i puntatori</li>
</td>
</tr>

<tr>
<td><b>25.</b>&nbsp; [3.05.01]</td>

<td>
<li>
&nbsp;Liste semplici, rappresetazioni sequenziale e collegata [<a href="#L1">2</a>]&nbsp;</li>
</td>

<td>
<li>
Quali sono le caretteristiche delle liste semplici; quali sono i vantaggi
e svantaggi della rappresentazione collegata mediante record e puntatori.</li>
</td>
</tr>

<tr>
<td><b>26.</b> [7.05.01]</td>

<td>
<li>
Inserimento e cancellazione di elementi da una lista mediante iterazioni
[<a href="#L1">2</a>]&nbsp;</li>
</td>

<td>
<li>
Come manipolare una lista rappresentata mediante record e puntatori</li>
</td>
</tr>

<tr>
<td><b>27.</b> [8.05.01]</td>

<td>Esercizi sulle liste&nbsp; [<a href="#L1">2</a>]&nbsp;</td>

<td>
<li>
Come effettuare le operazioni di inserimento e rimozione</li>
</td>
</tr>

<tr>
<td><b>28. </b>[9.05.01]</td>

<td>Esercizi sulle liste [<a href="#L1">2</a>]&nbsp;</td>

<td></td>
</tr>

<tr>
<td><i>10.05.01</i></td>

<td><b><i>SETTIMA </i>ESERCITAZIONE AUTOGUIDAT<i>A</i></b></td>

<td></td>
</tr>

<tr>
<td><b>29. </b>[15.05.01]</td>

<td>Grafi: definizioni di fgrafo, di cammino, ciclo, connessione [<a href="#L1">2</a>]&nbsp;</td>

<td>
<li>
Cosa e' un grafo orientato ed uno non orientato.&nbsp;</li>
</td>
</tr>

<tr>
<td><b>30. </b>[16.05.01]</td>

<td>Grafi: algoritmi di visita: in ampiezza e profondita' [<a href="#L1">2</a>]&nbsp;</td>

<td>
<li>
Come e' struttutato un algoritmo di visita</li>
</td>
</tr>

<tr>
<td><i>17.05.01</i></td>

<td><b><i>OTTAVA </i>ESERCITAZIONE AUTOGUIDAT<i>A</i></b></td>

<td></td>
</tr>

<tr>
<td><b>31.</b> [21.05.01]</td>

<td>Elementi di Fortran: caratteristiche del Fortran77. Tipi, variabili,
assegnazione ,
<br>il sistema di I/O, scelte&nbsp; e cicli[<a href="#L3">3</a>]</td>

<td>
<li>
Quali sono le differenze fra Pascal e Fortran77. Come usare delle variabili
ed i costrutti do ed if-then-else</li>
</td>
</tr>

<tr>
<td><b>32. </b>[22.05.01]</td>

<td>Elementi di Fortran:&nbsp;variabili dimensionate [<a href="#L3">3</a>]</td>

<td>
<li>
Come usare le variabili dimensionate</li>
</td>
</tr>

<tr>
<td><b>33.</b> [23.05.01]</td>

<td>Elementi di Fortran:&nbsp; sottopgroammi, aree common[<a href="#L3">3</a>]</td>

<td>
<li>
Come usare le subroutine e le function</li>
</td>
</tr>

<tr>
<td>24.05.01</td>

<td><b><i>NONA </i>ESERCITAZIONE AUTOGUIDAT<i>A</i></b></td>

<td></td>
</tr>
</table>

<br>&nbsp;
<p>
<hr WIDTH="100%">
<br><b><u>TESTI DI RIFERIMENTO</u></b>
<br>&nbsp;
<p><a NAME="L1"></a><b>[1]</b> S.Bergamaschi, C.Sartori, M.R.Scalas -
<i>Lezioni
di Fondamenti di Informatica</i> - 2a ed. - Esculapio, Progetto Leonardo,
Bologna, 1996.

<p><a NAME="L2"></a><b>[2]</b> D. Calvanese, P. Liberatore, F. Massacci,
R. Rosati <i>- <a href="/~pascal">Complementi ed esercizi di programmazione
in Pascal</a></i> - Esculapio, Progetto Leonardo, Bologna, 1999.

<p><a NAME="L3"></a><b>[3]</b> "Dal Pascal al Fortran." M.Casini Schaerf,
D.Nardi. 1996 (corso di Fondamenti di Informatica per i corsi di Laurea
in Ingegneria Chimica, dei Materiali, Elettrica,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Meccanica, Nucleare,
A.A. 2000/2001.)
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p><b><i>TESTI PER APPROFONDIMENTI</i></b>
<p><b>[3] </b>C. Batini, L. Carlucci Aiello, M. Lenzerini, A. Marchetti
Spaccamela, A. Miola - Fondamenti di programmazione dei calcolatori elettronici
- 11a ed., Franco Angeli, Milano, 2000.
<br>&nbsp;
<br>&nbsp;
</body>
</html>
